<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>íŒŒì´í”„ í¼ì¦ ë¯¸ë‹ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            padding-top: 50px;
            text-align: center;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 60px);
            gap: 5px;
            justify-content: center;
            margin-top: 20px;
        }
        .tile {
            width: 60px;
            height: 60px;
            background-color: #ffffff;
            border-radius: 6px;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            cursor: pointer;
            transition: background-color 0.2s; /* ìƒ‰ìƒ ì „í™˜ë§Œ ë‚¨ê¹€ */
            position: relative; /* SVG ìœ„ì¹˜ ì¡°ì •ì„ ìœ„í•´ */
            overflow: hidden; /* SVGê°€ íƒ€ì¼ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šë„ë¡ */
        }

        /* ê²Œì„ì´ ëë‚¬ì„ ë•Œ íƒ€ì¼ í´ë¦­ ë¹„í™œì„±í™” */
        .game-over .tile:not(.start):not(.end) {
            cursor: default;
            pointer-events: none; /* íŒŒì´í”„ íƒ€ì¼ í´ë¦­ ë¹„í™œì„±í™” */
        }


        /* SVG íŒŒì´í”„ ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
        .tile svg {
            width: 100%;
            height: 100%;
            transition: transform 0.2s; /* SVG íšŒì „ ì• ë‹ˆë©”ì´ì…˜ */
            position: absolute;
            top: 0;
            left: 0;
        }
        .tile svg path {
            stroke: #333; /* íŒŒì´í”„ ì„  ìƒ‰ìƒ */
            stroke-width: 8; /* íŒŒì´í”„ ì„  ë‘ê»˜ */
            fill: none; /* íŒŒì´í”„ ë‚´ë¶€ ì±„ìš°ê¸° ì—†ìŒ */
            stroke-linecap: round; /* ì„  ë ëª¨ì–‘ */
            transition: stroke 0.2s; /* ì„  ìƒ‰ìƒ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜ */
        }

        /* ì‹œì‘/ë ì§€ì  SVG í™”ì‚´í‘œ ìƒ‰ìƒ ë° ì±„ìš°ê¸° */
        .tile.start svg path,
        .tile.end svg path {
            fill: #333; /* í™”ì‚´í‘œëŠ” ì±„ìš°ê¸° */
            stroke: none; /* ì„  ì—†ìŒ */
        }

        /* SVG íŒŒì´í”„ íšŒì „ */
        .tile[data-type="straight"][data-rotation="0"] svg { transform: rotate(0deg); } /* â”‚ */
        .tile[data-type="straight"][data-rotation="1"] svg { transform: rotate(90deg); } /* â”€ */
        .tile[data-type="straight"][data-rotation="2"] svg { transform: rotate(180deg); } /* â”‚ */
        .tile[data-type="straight"][data-rotation="3"] svg { transform: rotate(270deg); } /* â”€ */

        .tile[data-type="bend"][data-rotation="0"] svg { transform: rotate(0deg); } /* â”” */
        .tile[data-type="bend"][data-rotation="1"] svg { transform: rotate(90deg); } /* â”Œ */
        .tile[data-type="bend"][data-rotation="2"] svg { transform: rotate(180deg); } /* â” */
        .tile[data-type="bend"][data-rotation="3"] svg { transform: rotate(270deg); } /* â”˜ */

        /* ì‹œì‘/ë ì§€ì  SVG í™”ì‚´í‘œ íšŒì „ */
        /* ê¸°ë³¸ì ìœ¼ë¡œ 'down' (ì•„ë˜ ë°©í–¥)ì„ í–¥í•˜ë„ë¡ ì •ì˜í•˜ê³  íšŒì „ */
        .tile.start[data-exit-dir="down"] svg { transform: rotate(0deg); }
        .tile.start[data-exit-dir="right"] svg { transform: rotate(90deg); }
        .tile.start[data-exit-dir="up"] svg { transform: rotate(180deg); }
        .tile.start[data-exit-dir="left"] svg { transform: rotate(270deg); }

        .tile.end[data-entry-dir="down"] svg { transform: rotate(180deg); } /* ì•„ë˜ì—ì„œ ë“¤ì–´ì˜¤ëŠ” í™”ì‚´í‘œëŠ” ìœ„ë¥¼ í–¥í•¨ */
        .tile.end[data-entry-dir="right"] svg { transform: rotate(270deg); } /* ì˜¤ë¥¸ìª½ì—ì„œ ë“¤ì–´ì˜¤ëŠ” í™”ì‚´í‘œëŠ” ì™¼ìª½ì„ í–¥í•¨ */
        .tile.end[data-entry-dir="up"] svg { transform: rotate(0deg); }     /* ìœ„ì—ì„œ ë“¤ì–´ì˜¤ëŠ” í™”ì‚´í‘œëŠ” ì•„ë˜ë¥¼ í–¥í•¨ */
        .tile.end[data-entry-dir="left"] svg { transform: rotate(90deg); }  /* ì™¼ìª½ì—ì„œ ë“¤ì–´ì˜¤ëŠ” í™”ì‚´í‘œëŠ” ì˜¤ë¥¸ìª½ì„ í–¥í•¨ */


        /* ì‹œì‘/ë ì§€ì  ë°°ê²½ ìƒ‰ìƒ */
        .start { background-color: #d1e7dd; } /* ì—°í•œ ì´ˆë¡ìƒ‰ */
        .end { background-color: #f8d7da; } /* ì—°í•œ ë¹¨ê°„ìƒ‰ */

        /* ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸ */
        .path-highlight {
            background-color: #a7d9b9 !important; /* ì„±ê³µ ê²½ë¡œ (ì§„í•œ ì´ˆë¡) */
        }
        .no-path-highlight {
            background-color: #ffeeba !important; /* ì—°ê²° ì‹¤íŒ¨ ë¶€ë¶„ (ì—°í•œ ë…¸ë‘) */
        }

        /* ë¬¼ íë¦„ ì• ë‹ˆë©”ì´ì…˜ */
        .flowing-water path {
            stroke: #4dc2f0 !important; /* ë¬¼ ìƒ‰ìƒ */
            animation: flow 1s linear infinite; /* ë¬¼ íë¦„ ì• ë‹ˆë©”ì´ì…˜ */
            stroke-dasharray: 20 20; /* ë¬¼ë°©ìš¸ íš¨ê³¼ */
        }
        /* ì‹œì‘/ë ì§€ì  í™”ì‚´í‘œ ë¬¼ ìƒ‰ìƒ */
        .tile.start.flowing-water svg path,
        .tile.end.flowing-water svg path {
             fill: #4dc2f0 !important; /* í™”ì‚´í‘œë„ ë¬¼ìƒ‰ìœ¼ë¡œ */
        }


        @keyframes flow {
            to {
                stroke-dashoffset: -40;
            }
        }

        /* ë””ë²„ê·¸ ì •ë³´ í‘œì‹œ ìŠ¤íƒ€ì¼ */
        #debugInfo {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            text-align: left;
            font-family: monospace;
            white-space: pre-wrap; /* ì¤„ë°”ê¿ˆ ìœ ì§€ */
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body>
    <h1 class="mb-3">ğŸ›  íŒŒì´í”„ í¼ì¦ ë¯¸ë‹ˆ</h1>
    <p class="text-muted">íƒ€ì¼ì„ íšŒì „í•´ Sì—ì„œ Eê¹Œì§€ ë¬¼ê¸¸ì„ ì™„ì„±í•˜ì„¸ìš”!</p>
    <div id="grid" class="grid"></div>
    <button id="checkPathBtn" class="btn btn-primary mt-3">ì—°ê²° í™•ì¸</button>
    <button id="newGameBtn" class="btn btn-secondary mt-3 ms-2">ìƒˆ ê²Œì„</button>
    <p id="status" class="mt-3 fs-5 fw-bold"></p>

    <div id="debugInfo">
        <h3>ë””ë²„ê·¸ ì •ë³´:</h3>
        <p>ì‹œì‘ ì§€ì  (S) exitDir: <span id="debug_start_exitDir"></span></p>
        <p>ì¢…ë£Œ ì§€ì  (E) entryDir: <span id="debug_end_entryDir"></span></p>
        <p id="debug_dfs_status"></p>
    </div>

    <script>
        const gridSize = 4;
        let board = []; // ê²Œì„ ë³´ë“œ ìƒíƒœë¥¼ ì €ì¥í•  2D ë°°ì—´
        let isGameOver = false; // ê²Œì„ ì¢…ë£Œ ìƒíƒœ í”Œë˜ê·¸

        // íŒŒì´í”„ íƒ€ì… ì •ì˜ (SVG ê²½ë¡œ)
        const tileTypes = {
            straight: {
                // SVG path for a vertical straight pipe (center-top to center-bottom)
                svgPath: '<path d="M30 0 V60"/>',
                connections: [["up", "down"]], // ê¸°ë³¸ ì—°ê²°ì€ ìœ„-ì•„ë˜
            },
            bend: {
                // SVG path for a bend pipe (left-center to center-bottom)
                svgPath: '<path d="M0 30 H30 V60"/>',
                connections: [["left", "down"]], // ê¸°ë³¸ ì—°ê²°ì€ ì™¼ìª½-ì•„ë˜
            },
            start: { // ì‹œì‘ ì§€ì  í™”ì‚´í‘œ (ê¸°ë³¸: ì•„ë˜ë¥¼ í–¥í•¨)
                svgPath: '<path d="M30 0 V40 M20 30 L30 40 L40 30 Z"/>' // ì„ ê³¼ ì‚¼ê°í˜• í™”ì‚´í‘œ
            },
            end: { // ë ì§€ì  í™”ì‚´í‘œ (ê¸°ë³¸: ì•„ë˜ì—ì„œ ìœ„ë¡œ ë“¤ì–´ì˜¤ëŠ” ëª¨ì–‘)
                svgPath: '<path d="M30 60 V20 M20 30 L30 20 L40 30 Z"/>' // ì„ ê³¼ ì‚¼ê°í˜• í™”ì‚´í‘œ
            }
        };

        // ë°©í–¥ ë²¡í„° (row, col ë³€í™”ëŸ‰)
        const directions = {
            up: [-1, 0],
            down: [1, 0],
            left: [0, -1],
            right: [0, 1]
        };

        // ë°˜ëŒ€ ë°©í–¥ ë§¤í•‘
        const oppositeDir = {
            up: "down",
            down: "up",
            left: "right",
            right: "left"
        };

        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---

        // íŠ¹ì • ë°©í–¥ì„ ì‹œê³„ë°©í–¥ìœ¼ë¡œ íšŒì „
        function rotateDir(dir, times = 1) {
            const order = ["up", "right", "down", "left"];
            const idx = order.indexOf(dir);
            return order[(idx + times) % 4];
        }

        // íƒ€ì¼ì˜ í˜„ì¬ íšŒì „ê°’ì— ë”°ë¥¸ ì‹¤ì œ ì—°ê²° ë°©í–¥ë“¤ì„ ë°˜í™˜
        // ë°˜í™˜ ê°’ì€ [["dir1", "dir2"], ["dir3", "dir4"] ...] í˜•íƒœ
        function getTileConnections(type, rotation) {
            // ì‹œì‘/ë íƒ€ì¼ì€ ë¯¸ë¦¬ ì •ì˜ëœ exitDir/entryDirë§Œ ê°€ì§, íšŒì „ê³¼ ë¬´ê´€
            if (type === "start" || type === "end") return []; // connections ë°°ì—´ì´ ì˜ë¯¸ ì—†ìŒ
            return tileTypes[type].connections.map(pair =>
                pair.map(d => rotateDir(d, rotation))
            );
        }

        // íŠ¹ì • íƒ€ì¼ì´ ì£¼ì–´ì§„ ë°©í–¥ìœ¼ë¡œ ë¬¼ì„ ë°›ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
        function canReceiveWater(tile, direction) {
            if (!tile) return false;

            if (tile.type === "start") {
                // ì‹œì‘ íƒ€ì¼ì€ ë¬¼ì„ ë°›ì§€ ì•Šê³  ë‚´ë³´ë‚´ê¸°ë§Œ í•¨ (ì²« DFS í˜¸ì¶œ ì‹œ null ì²˜ë¦¬ë¨)
                return false;
            } else if (tile.type === "end") {
                // ë íƒ€ì¼ì€ entryDirë¡œë§Œ ë¬¼ì„ ë°›ì„ ìˆ˜ ìˆìŒ
                return tile.entryDir === direction;
            } else { // ì¼ë°˜ íŒŒì´í”„
                const connections = getTileConnections(tile.type, tile.rotation);
                // ì—°ê²° ìŒ ì¤‘ í•˜ë‚˜ë¼ë„ ë“¤ì–´ì˜¤ëŠ” ë°©í–¥ì„ í¬í•¨í•˜ë©´ true
                return connections.some(pair => pair.includes(direction));
            }
        }

        // (r1, c1)ì—ì„œ (r2, c2)ë¡œì˜ ë°©í–¥ ê³„ì‚°
        function getDirection(r1, c1, r2, c2) {
            if (r2 === r1 - 1) return "up";
            if (r2 === r1 + 1) return "down";
            if (c2 === c1 - 1) return "left";
            if (c2 === c1 + 1) return "right";
            return null; // ì¸ì ‘í•˜ì§€ ì•ŠìŒ
        }

        // ë‘ ë°©í–¥ì„ ì—°ê²°í•˜ê¸° ìœ„í•œ íƒ€ì¼ íƒ€ì… ë° íšŒì „ê°’ ê²°ì •
        function getTileConfigFromDirs(fromDir, toDir) {
            const pairs = {
                // ì§ì„  íŒŒì´í”„ (ìˆ˜ì§ ê¸°ë³¸: rotation 0, ìˆ˜í‰: rotation 1)
                "up,down": {type: "straight", rotation: 0},
                "down,up": {type: "straight", rotation: 0},
                "left,right": {type: "straight", rotation: 1},
                "right,left": {type: "straight", rotation: 1},

                // êµ½ì€ íŒŒì´í”„ (ê¸°ë³¸: â”” - left, down ì—°ê²°)
                "left,down": {type: "bend", rotation: 0}, // â””
                "down,left": {type: "bend", rotation: 0},

                "up,right": {type: "bend", rotation: 1}, // â”Œ (â””ì„ 90ë„ íšŒì „)
                "right,up": {type: "bend", rotation: 1},

                "right,down": {type: "bend", rotation: 2}, // â” (â””ì„ 180ë„ íšŒì „)
                "down,right": {type: "bend", rotation: 2},

                "left,up": {type: "bend", rotation: 3}, // â”˜ (â””ì„ 270ë„ íšŒì „)
                "up,left": {type: "bend", rotation: 3},
            };
            const key1 = `${fromDir},${toDir}`;
            const key2 = `${toDir},${fromDir}`; // ë°˜ëŒ€ ë°©í–¥ë„ ë™ì¼í•œ íŒŒì´í”„

            // ì—°ê²°ë˜ëŠ” ë‘ ë°©í–¥ì— ë”°ë¼ ì ì ˆí•œ íŒŒì´í”„ íƒ€ì…ì„ ë°˜í™˜
            // ë§Œì•½ ìœ íš¨í•œ ì—°ê²°ì´ ì•„ë‹ˆë©´ ê¸°ë³¸ê°’ìœ¼ë¡œ straightë¥¼ ë°˜í™˜ (ë¹„ì •ìƒ ê²½ë¡œ ëŒ€ë¹„)
            return pairs[key1] || pairs[key2] || {type: "straight", rotation: 0};
        }


        // --- ê²Œì„ ë¡œì§ ---

        // ê²Œì„ ë³´ë“œë¥¼ ì´ˆê¸°í™”í•˜ê³  ë Œë”ë§
        function createBoard() {
            isGameOver = false; // ê²Œì„ ì‹œì‘ ì‹œ ìƒíƒœ ì´ˆê¸°í™”
            $('#grid').empty().removeClass('game-over'); // ê¸°ì¡´ ê·¸ë¦¬ë“œ ë¹„ìš°ê¸° ë° í´ë˜ìŠ¤ ì œê±°
            board = Array.from({length: gridSize}, () => Array(gridSize).fill(null));

            // 1. í•­ìƒ í’€ ìˆ˜ ìˆëŠ” ê²½ë¡œ ìƒì„± (S -> E)
            const solvablePath = [];
            let r = 0, c = 0;
            solvablePath.push([r, c]);
            while (r !== gridSize - 1 || c !== gridSize - 1) {
                const possibleMoves = [];
                // ê°€ëŠ¥í•œ ë‹¤ìŒ ì¹¸ì´ ê²©ì ë‚´ì— ìˆì„ ë•Œë§Œ ì´ë™
                if (r + 1 < gridSize) possibleMoves.push("down");
                if (c + 1 < gridSize) possibleMoves.push("right");
                
                // ëì— ë„ë‹¬í–ˆê±°ë‚˜ ë” ì´ìƒ ì´ë™í•  ìˆ˜ ì—†ìœ¼ë©´ ì¢…ë£Œ (ì•ˆì „ì¥ì¹˜)
                if (r === gridSize - 1 && c === gridSize - 1) break;
                if (possibleMoves.length === 0) {
                     // ë§Œì•½ Sì—ì„œ Eë¡œ ê°€ëŠ” ê²½ë¡œ ìƒì„±ì´ ë§‰í˜”ë‹¤ë©´, ì¬ì‹œë„ (ë§¤ìš° ë“œë¬¼ê²Œ ë°œìƒ)
                    r=0; c=0; solvablePath.length = 0; solvablePath.push([r,c]);
                    continue; // ê²½ë¡œ ì¬ì‹œë„
                }
                
                const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                if (move === "down") r++;
                else c++;
                solvablePath.push([r, c]);
            }

            // 2. ê²½ë¡œì— ë”°ë¼ íƒ€ì¼ ë°°ì¹˜ (S, E, ê·¸ë¦¬ê³  ì—°ê²°ëœ íŒŒì´í”„)
            for (let i = 0; i < solvablePath.length; i++) {
                const [curR, curC] = solvablePath[i];
                let tileData;

                if (i === 0) { // ì‹œì‘ íƒ€ì¼ (S)
                    const [nextR, nextC] = solvablePath[i + 1];
                    const exitDir = getDirection(curR, curC, nextR, nextC);
                    tileData = {type: "start", exitDir: exitDir, r: curR, c: curC};
                } else if (i === solvablePath.length - 1) { // ë íƒ€ì¼ (E)
                    const [prevR, prevC] = solvablePath[i - 1];
                    //const entryDir = getDirection(prevR, prevC, curR, curC);
				    const entryDir = "up"; 
                    tileData = {type: "end", entryDir: entryDir, r: curR, c: curC};
                } else { // ì¤‘ê°„ ê²½ë¡œ íƒ€ì¼
                    const [prevR, prevC] = solvablePath[i - 1];
                    const [nextR, nextC] = solvablePath[i + 1];
                    const from = getDirection(prevR, prevC, curR, curC);
                    const to = getDirection(curR, curC, nextR, nextC);
                    const {type, rotation} = getTileConfigFromDirs(from, to);
                    tileData = {type, rotation, r: curR, c: curC};
                }
                board[curR][curC] = tileData;
            }

            // 3. ë‚˜ë¨¸ì§€ ì¹¸ì„ ë¬´ì‘ìœ„ íƒ€ì¼ë¡œ ì±„ìš°ê³  DOMì— ì¶”ê°€
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const existingTile = board[r][c];
                    let tile;

                    if (existingTile) {
                        tile = existingTile; // ì´ë¯¸ ê²½ë¡œì— ë°°ì¹˜ëœ íƒ€ì¼
                    } else { // ë¹„ì–´ìˆëŠ” ì¹¸ (ë¬´ì‘ìœ„ íƒ€ì¼)
                        const types = ["straight", "bend"]; // ì‹œì‘/ë íƒ€ì¼ ì œì™¸
                        const randomType = types[Math.floor(Math.random() * types.length)];
                        const randomRotation = Math.floor(Math.random() * 4);
                        tile = {type: randomType, rotation: randomRotation, r, c};
                        board[r][c] = tile;
                    }

                    // DOM ìš”ì†Œ ìƒì„± ë° ì†ì„± ì„¤ì •
                    const $tileDiv = $('<div>')
                        .addClass('tile')
                        .attr('data-row', r)
                        .attr('data-col', c);

                    // SVG ì•„ì´ì½˜ ì¶”ê°€
                    const svgHtml = `<svg viewbox="0 0 60 60">${tileTypes[tile.type].svgPath}</svg>`;
                    $tileDiv.html(svgHtml);

                    if (tile.type === "start") {
                        $tileDiv.addClass('start').attr('data-exit-dir', tile.exitDir);
                    } else if (tile.type === "end") {
                        $tileDiv.addClass('end').attr('data-entry-dir', tile.entryDir);
                    } else { // ì¼ë°˜ íŒŒì´í”„
                        $tileDiv.attr('data-type', tile.type)
                                .attr('data-rotation', tile.rotation)
                                .on('click', function() {
                                    if (!isGameOver) { // ê²Œì„ ì˜¤ë²„ê°€ ì•„ë‹ ë•Œë§Œ í´ë¦­ í—ˆìš©
                                        rotateTile(r, c);
                                    }
                                });
                    }

                    tile.el = $tileDiv; // DOM ìš”ì†Œ ì°¸ì¡° ì €ì¥
                    $('#grid').append($tileDiv);
                }
            }

            // 4. S, Eë¥¼ ì œì™¸í•œ ëª¨ë“  íŒŒì´í”„ë¥¼ ë¬´ì‘ìœ„ë¡œ ì„ê¸°
            board.flat().forEach(tile => {
                if (tile && tile.type !== "start" && tile.type !== "end") {
                    const randomRotations = Math.floor(Math.random() * 4);
                    for (let i = 0; i < randomRotations; i++) {
                        rotateTile(tile.r, tile.c, false); // ì‹œê° ì—…ë°ì´íŠ¸ ì—†ì´ íšŒì „
                    }
                }
            });

            $('#status').text("ë¬¼ê¸¸ì„ ì—°ê²°í•´ ì£¼ì„¸ìš”!");
            updateDebugInfo(); // ë””ë²„ê·¸ ì •ë³´ ì—…ë°ì´íŠ¸
        }

        // íƒ€ì¼ íšŒì „ (ë…¼ë¦¬ì  rotation ì—…ë°ì´íŠ¸ ë° CSS ì ìš©)
        function rotateTile(r, c, updateStatus = true) {
            const tile = board[r][c];
            // ê²Œì„ ì˜¤ë²„ ìƒíƒœì´ê±°ë‚˜ ì‹œì‘/ë íƒ€ì¼ì´ë©´ íšŒì „ ë¶ˆê°€
            if (!tile || tile.type === "start" || tile.type === "end" || isGameOver) return;

            tile.rotation = (tile.rotation + 1) % 4;
            $(tile.el).attr('data-rotation', tile.rotation); // CSSê°€ SVGë¥¼ íšŒì „í•˜ë„ë¡ data-rotation ì—…ë°ì´íŠ¸

            if (updateStatus) {
                $('#status').text("ë¬¼ê¸¸ì„ ì—°ê²°í•´ ì£¼ì„¸ìš”!");
                resetTileColors(); // ìƒ‰ìƒ ì´ˆê¸°í™”
                updateDebugInfo(); // ë””ë²„ê·¸ ì •ë³´ ì—…ë°ì´íŠ¸
            }
        }

        // ëª¨ë“  íƒ€ì¼ ìƒ‰ìƒ ì´ˆê¸°í™” (í•˜ì´ë¼ì´íŠ¸ ì œê±°)
        function resetTileColors() {
            $('.tile').css('background-color', '') // Bootstrap ê¸°ë³¸ìœ¼ë¡œ
                      .removeClass('path-highlight no-path-highlight flowing-water'); /* flowing-water ì œê±° */
            $('.start').css('background-color', ''); // ê¸°ë³¸ CSSë¡œ ëŒì•„ê°
            $('.end').css('background-color', '');   // ê¸°ë³¸ CSSë¡œ ëŒì•„ê°
        }

        // --- ê²½ë¡œ í™•ì¸ ë¡œì§ (DFS) ---
        function checkPath() {
            resetTileColors(); // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì´ˆê¸°í™”
            if (isGameOver) return; // ê²Œì„ ì¢…ë£Œ ìƒíƒœì´ë©´ ë‹¤ì‹œ í™•ì¸í•˜ì§€ ì•ŠìŒ

            const visited = Array.from({length: gridSize}, () => Array(gridSize).fill(false));
            const currentPath = []; // í˜„ì¬ íƒìƒ‰ ì¤‘ì¸ ê²½ë¡œ
            let dfsStatusMessage = ""; // DFS ì§„í–‰ ìƒí™© ë©”ì‹œì§€

            // DFS ì¬ê·€ í•¨ìˆ˜
            // r, c: í˜„ì¬ íƒ€ì¼ì˜ ì¢Œí‘œ
            // incomingDir: í˜„ì¬ íƒ€ì¼ë¡œ ë¬¼ì´ ë“¤ì–´ì˜¤ëŠ” ë°©í–¥ (nullì´ë©´ ì‹œì‘ ì§€ì )
            function dfs(r, c, incomingDir) {
                // 1. ìœ íš¨ì„± ê²€ì‚¬: ê²©ì ë°–, ì´ë¯¸ ë°©ë¬¸í•œ íƒ€ì¼, ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íƒ€ì¼
                if (r < 0 || c < 0 || r >= gridSize || c >= gridSize || visited[r][c]) {
                    // console.log(`[DFS] (${r}, ${c}) - Invalid or already visited.`);
                    return false;
                }
                const tile = board[r][c];
                if (!tile) {
                    // console.log(`[DFS] (${r}, ${c}) - No tile data.`);
                    return false; // íƒ€ì¼ ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš°
                }

                // console.log(`[DFS] Visiting: (${r}, ${c}), Type: ${tile.type}, Incoming: ${incomingDir}, Rotation: ${tile.rotation || 'N/A'}`);

                visited[r][c] = true; // ë°©ë¬¸ í‘œì‹œ
                currentPath.push([r, c]); // ê²½ë¡œì— ì¶”ê°€

                // 2. ì‹œì‘ íƒ€ì¼ ì²˜ë¦¬
                if (tile.type === "start") {
                    if (incomingDir !== null) { // ì‹œì‘ íƒ€ì¼ì— ë‹¤ë¥¸ ë°©í–¥ì—ì„œ ë“¤ì–´ì˜¤ë©´ ì•ˆ ë¨
                        // console.log(`[START TILE] (${r}, ${c}) - Invalid incoming direction: ${incomingDir}`);
                        currentPath.pop();
                        return false;
                    }

                    const [dr, dc] = directions[tile.exitDir];
                    const nextR = r + dr;
                    const nextC = c + dc;
                    
                    // ë‹¤ìŒ ì¹¸ì´ ìœ íš¨í•˜ê³ , ë‹¤ìŒ ì¹¸ì´ í˜„ì¬ íƒ€ì¼ì˜ ì¶œêµ¬ ë°©í–¥ì„ ë°›ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
                    if (nextR >= 0 && nextR < gridSize && nextC >= 0 && nextC < gridSize) {
                        const nextTile = board[nextR][nextC];
                        if (nextTile && canReceiveWater(nextTile, oppositeDir[tile.exitDir])) {
                            if (dfs(nextR, nextC, oppositeDir[tile.exitDir])) {
                                return true; // ê²½ë¡œ ë°œê²¬
                            }
                        } else {
                            // console.log(`[START TILE] (${r}, ${c}) -> (${nextR}, ${nextC}) - Next tile cannot receive water from ${oppositeDir[tile.exitDir]}`);
                        }
                    } else {
                        // console.log(`[START TILE] (${r}, ${c}) -> (${nextR}, ${nextC}) - Next position out of bounds.`);
                    }
                }
                // 3. ë íƒ€ì¼ ì²˜ë¦¬
                else if (tile.type === "end") {
                    dfsStatusMessage = `ì¢…ë£Œ ì§€ì  (${r}, ${c}) ë„ë‹¬.\n` +
                                       `ë“¤ì–´ì˜¨ ë°©í–¥: ${incomingDir || 'ì—†ìŒ'}\n` +
                                       `ê¸°ëŒ€í•˜ëŠ” ë°©í–¥: ${tile.entryDir || 'ì—†ìŒ'}`;
                    if (incomingDir === tile.entryDir) {
                        dfsStatusMessage += `\nâœ… ì„±ê³µ: ë“¤ì–´ì˜¨ ë°©í–¥ ì¼ì¹˜!`;
                        return true; // ìµœì¢… ëª©ì ì§€ì— ë„ë‹¬! ê²½ë¡œ ë°œê²¬
                    } else {
                        dfsStatusMessage += `\nâŒ ì‹¤íŒ¨: ë“¤ì–´ì˜¨ ë°©í–¥ ë¶ˆì¼ì¹˜!`;
                        currentPath.pop(); // ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ê²½ë¡œì—ì„œ ì œê±°í•˜ê³  ì‹¤íŒ¨
                        return false;
                    }
                }
                // 4. ì¼ë°˜ íŒŒì´í”„ íƒ€ì¼ ì²˜ë¦¬
                else {
                    // í˜„ì¬ íƒ€ì¼ì´ incomingDirë¡œ ë¬¼ì„ ë°›ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
                    if (!canReceiveWater(tile, incomingDir)) {
                         // console.log(`[PIPE TILE] (${r}, ${c}) - Cannot receive water from ${incomingDir}`);
                         currentPath.pop();
                         return false;
                    }

                    const tileConnections = getTileConnections(tile.type, tile.rotation);
                    let foundNextStep = false;

                    for (let [conn1, conn2] of tileConnections) {
                        let nextOutDir = null; // í˜„ì¬ íƒ€ì¼ì—ì„œ ë‚˜ê°€ëŠ” ë°©í–¥

                        // í˜„ì¬ íƒ€ì¼ë¡œ 'ë“¤ì–´ì˜¨' ë°©í–¥ê³¼ ì¼ì¹˜í•˜ëŠ” ì—°ê²° ì§€ì ì„ ì°¾ê³ , ê·¸ 'ë°˜ëŒ€í¸'ì´ ë¬¼ì´ 'ë‚˜ê°€ëŠ”' ë°©í–¥ì´ ë¨
                        if (conn1 === incomingDir) nextOutDir = conn2;
                        else if (conn2 === incomingDir) nextOutDir = conn1;

                        if (nextOutDir) { // ë¬¼ì´ ë‚˜ê°ˆ ìˆ˜ ìˆëŠ” ìœ íš¨í•œ ë°©í–¥ì„ ì°¾ì•˜ë‹¤ë©´
                            const [dr, dc] = directions[nextOutDir];
                            const nextR = r + dr;
                            const nextC = c + dc;

                            // ë‹¤ìŒ ì¹¸ì˜ ìœ íš¨ì„± ê²€ì‚¬ (ê²©ì ë²”ìœ„ ë‚´)
                            if (nextR >= 0 && nextR < gridSize && nextC >= 0 && nextC < gridSize) {
                                const nextTile = board[nextR][nextC];
                                if (nextTile) {
                                    // ë‹¤ìŒ íƒ€ì¼ì´ í˜„ì¬ íƒ€ì¼ì—ì„œ ë‚˜ê°€ëŠ” ë°©í–¥ì˜ ë°˜ëŒ€ë¥¼ ë°›ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
                                    if (canReceiveWater(nextTile, oppositeDir[nextOutDir])) {
                                        if (dfs(nextR, nextC, oppositeDir[nextOutDir])) {
                                            foundNextStep = true;
                                            break; // ê²½ë¡œ ë°œê²¬í–ˆìœ¼ë‹ˆ ë” ì´ìƒ íƒìƒ‰ ë¶ˆí•„ìš”
                                        }
                                    } else {
                                        // console.log(`[PIPE TILE] (${r}, ${c}) -> (${nextR}, ${nextC}) - Next tile cannot receive water from ${oppositeDir[nextOutDir]}`);
                                    }
                                } else {
                                    // console.log(`[PIPE TILE] (${r}, ${c}) -> (${nextR}, ${nextC}) - Next tile is null.`);
                                }
                            } else {
                                // console.log(`[PIPE TILE] (${r}, ${c}) -> (${nextR}, ${nextC}) - Next position out of bounds.`);
                            }
                        }
                    }
                    if (foundNextStep) return true; // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì„±ê³µì ìœ¼ë¡œ ì§„í–‰
                }

                // í˜„ì¬ íƒ€ì¼ì—ì„œ ë” ì´ìƒ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìœ¼ë©´ ë°±íŠ¸ë˜í‚¹ (ê²½ë¡œì—ì„œ ì œê±°)
                currentPath.pop();
                return false;
            }

            // DFS ì‹œì‘: ì‹œì‘ íƒ€ì¼(0,0)ì—ì„œ ë¬¼ì„ ë³´ë‚´ê¸° ì‹œì‘ (incomingDirëŠ” null)
            const pathFound = dfs(0, 0, null);

            // --- ì‹œê°ì  í”¼ë“œë°± ë° ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬ ---
            if (pathFound) {
                $('#status').text("ğŸ‰ ê²Œì„ í´ë¦¬ì–´! ë¬¼ì´ ë„ì°©ì§€ê¹Œì§€ ì™„ë²½í•˜ê²Œ í˜ë €ìŠµë‹ˆë‹¤!");
                isGameOver = true; // ê²Œì„ ì¢…ë£Œ í”Œë˜ê·¸ ì„¤ì •
                $('#grid').addClass('game-over'); // ê·¸ë¦¬ë“œì— game-over í´ë˜ìŠ¤ ì¶”ê°€ (í´ë¦­ ë¹„í™œì„±í™”ìš©)

                // ì„±ê³µ ê²½ë¡œì˜ íƒ€ì¼ í•˜ì´ë¼ì´íŠ¸ ë° ë¬¼ íë¦„ íš¨ê³¼ ì¶”ê°€
                board.flat().forEach(tile => {
                    const isPartOfPath = currentPath.some(([pr, pc]) => pr === tile.r && pc === tile.c);
                    if (isPartOfPath) {
                        $(tile.el).addClass("path-highlight flowing-water");
                    } else if (tile.type !== "start" && tile.type !== "end") {
                         $(tile.el).addClass("no-path-highlight");
                    }
                });
            } else {
                $('#status').text("âŒ ì•„ì§ ë¬¼ê¸¸ì´ ì™„ì„±ë˜ì§€ ì•Šì•˜ì–´ìš”. ë‹¤ì‹œ ì‹œë„í•´ ë³´ì„¸ìš”!");
                // ë°©ë¬¸í–ˆì§€ë§Œ ì—°ê²° ì‹¤íŒ¨í•œ íƒ€ì¼ í•˜ì´ë¼ì´íŠ¸
                board.flat().forEach(tile => {
                    if (tile && tile.type !== "start" && tile.type !== "end") {
                        const wasVisited = visited[tile.r][tile.c];
                        if (wasVisited) {
                            $(tile.el).addClass("no-path-highlight");
                        }
                    }
                });
            }
            $('#debug_dfs_status').text(dfsStatusMessage); // DFS ê²°ê³¼ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        }

        // --- ë””ë²„ê·¸ ì •ë³´ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ---
        function updateDebugInfo() {
            const startTile = board[0][0];
            const endTile = board[gridSize - 1][gridSize - 1];

            if (startTile && startTile.type === "start") {
                $('#debug_start_exitDir').text(startTile.exitDir || 'N/A');
            } else {
                $('#debug_start_exitDir').text('ì‹œì‘ íƒ€ì¼ ì—†ìŒ ë˜ëŠ” ì´ìƒ');
            }

            if (endTile && endTile.type === "end") {
                $('#debug_end_entryDir').text(endTile.entryDir || 'N/A');
            } else {
                $('#debug_end_entryDir').text('ì¢…ë£Œ íƒ€ì¼ ì—†ìŒ ë˜ëŠ” ì´ìƒ');
            }
            $('#debug_dfs_status').text(''); // DFS ìƒíƒœ ì´ˆê¸°í™”
        }

        // --- ì´ˆê¸°í™” ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---
        function initGame() {
            createBoard();
            resetTileColors(); // í˜¹ì‹œ ëª¨ë¥¼ ì”ì—¬ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            $('#status').text("ë¬¼ê¸¸ì„ ì—°ê²°í•´ ì£¼ì„¸ìš”!");
        }

        // DOM ë¡œë“œ í›„ ì´ˆê¸°í™” ë° ì´ë²¤íŠ¸ ë°”ì¸ë”©
        $(document).ready(function() {
            initGame(); // í˜ì´ì§€ ë¡œë“œ ì‹œ ê²Œì„ ì´ˆê¸°í™”

            // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ë°”ì¸ë”© (jQuery ì‚¬ìš©)
            $('#checkPathBtn').on('click', checkPath);
            $('#newGameBtn').on('click', initGame);
        });
    </script>
</body>
</html>
